효율성 (투포인터 알고리즘, sliding window, hash map)

1. 두 배열 합치기 
    //sort()를 쓰면 시간복잡도가 nlogn인데
    //TPA 쓰면 O(n+m) 이다 
    //팁: pointer iterate 할 때 while 문, ++ 활용 하삼 

2. 공통원소 구하기 
    //try1
        //[2,3]까지는 구했는데 5까지 안나옴

        //이 문법을 구현하고 싶은데 못했음
        //아직 한 쪽이 끝까지 iterate 안됐는데 다른 한 쪽이 null 쳤을 경우 
        //다시 처음으로 돌ㄹ려라 왜냐면 아직 교집합인지 확인 안된 (5)수가 있을ㄹ 수도 있어서

        한 거 같은데 맞는지 확인 부탁 

        //로직 
        //먼저 arr1 arr2 오름차순 정렬 !!!! 이게 바로 핵심 ㅇㅇ
        // 왜냐면 오름차순으로 미리 정리했을ㄹ 때 p1 p2 를 차례로 iterate 한다면 
        //p1[0]<p2[0] 이고 p1[0]가 p2[0]가 같지 않았을 때 
        //p1[0]이 p2[0] 이후의 숫자에 나타날 가능성이 없음. 그래서 한 배열 iterate 다하면 끝내도 되는 것

    //try2
        //맞았음 근데 
        else if(arr1[p1]<arr2[p2]) p1++;
                else p2++;
        이렇게 적어도 될걸 else로 한번더 감쌌었ㅇ므;;
    
03. 연속 부분수열1
    //로직
    //0부터 iterate 하면서 이중 포문 돌기 
            //투포인터알골리즘 O(n)으로 하는 방법
            //lt=0, rt=0 으로 해서 동시 시작, lt는 고정
            //rt가 계속 옆으로 가면서 sum이라는 수에 원소를 더함.
            //sum이 m보다 작을 경우 계속 더함
            //m보다 커지면 lt를 움직여서 다시 시작, m이랑 같으면 arr[lt:rt+1]이 부분수열, cnt++
    
    //try1
        // 잘ㄹ 구현한 거 같은데 3이 아니라 2가 나오고 
        //lt, rt 뽑아보니까 [1,3] [2,5] [4,7] 나와야하는데 
        //[1,3] [2,6] [2,] 나옴

        //내가 생각한 로직은 rt만 옆으로 움직이는 거였는데 

        //lt를 옆으로 움직이면서 원래 Lt가 가지고 있는 값을 
        //sum에서 빼주고, rt를 움직여서 6이 되는지 확인..
        //rt가 수열 끝을 터치하면 끝 

        //로직 정답& 주요포인트
        //sum에다가 arr[rt]를 더하고 
        //sum 값이 m이랑 같은지 다른지 항상 확인 
            //m이랑 같으면 count++ 그리고 arr[lt]를 빼주고 lt값을++ !! 다음으로 넘어가기 위해  또 sum 과의 관계 쳌
            //m보다 작으면 rt값을 하나 더 늘ㄹ려서 sum에 추가해줌
            //m보다 크면 sum에서 arr[lt]를 빼주고 lt값을++ 시킴 ,
                //그리고 또 m값과 같아지는지 체크, 같으면 count++시켜지겠지만  
                //m보다 작아지면 다시 rt가 증가되겠지 그래서 for문이 제일 바깥에 있는 거임 
        
04. 연속 부분수열2
    //try1
        //거의 다 왔는데에에에엙...ㅠㅠㅠㅠ
        //수열의 제일ㄹ 마지막 수만 빼고 부분수열의 모든 경우의 수가 저장됐음 
        //답 10인데 9 나옴 흐흐으헹흐ㅔㅇ

    
    //로직 정답
        //lt rt 는 수열 첫 부분부터 시작함
        //sum에 arr[rt] 더함. if m보다 작으면
        //이제 rt++
        //sum에다가 arr[rt]를 더함 
        //sum이 m보다 작으면 arr[rt]를 포함하는, arr[rt]까지의 ㅣ부분수열의 갯수를ㄹ 구함 
            //부분수열의 개수는 rt-lt+1 하면 나온다 
        //또 다시 rtㄹ를 증가하고 더해주는데 그랬을 때 sum보다 크면 ltㄹ를 늘리고 뺌. 
            //빼서 합이 m보다 작으면 그 구간에 대해서도 부분수열의 갯수 구해야함 
        
        //힌트: while 안에 조건식은 참이 아니면 실행되지 않음 건너뜀.
        //      그리고 참일 때 들어가면 조건식이 거짓이 될때까지 무한반복
        //      그 다음에 다음 줄로 넘어가게 된다 

05. 최대 매출
    //try1 1솔! 근데 시간복잡도가 높을ㄹ 듯 그냥 twopointeralg 나름 썼오.... ㅎㅎ 
            //근데 결국 i,j이중 포문 쓴거지만 어쨌든 풀ㄹ엇음
        
    //로직 정답
        //일단 이중 for문 안쓸거고, initial sum 부터 구하고 sliding window 사용해서
        //끝 element 없애고 앞 element 더함 

06. 학급 회장
    let sH = new Map();
            for (let x of str){
                if(sH.has(x)) sH.set(x, sH.get(x)+1);
    for(let [key, val] of sH){

    //로직 정답
        //new Map(), for(let [key,val]), .has, .set() 잘 사용하기

07. 아나그램
    //(쌤 로직 설명 듣고) 1솔ㄹㄹ

    //로직
    //아닌 경우를 먼저 생각하는 게 좋을 듯
            //첫번째 sH의 key 모두가 두번쨰에 있는지
            //그 다음 갯수가 동일한지

            //str1 에 대해서만 map 만들고 
            //str2 iterate 하면서 str1 map 의 key와 일치할 때마다 value-1해서 상쇄



    //차이점
        for(let x of str2){
                    if(!sH.has(x) || sH.get(x)==0) return "NO"; 
                    sH.set(x, sH.get(x)-1);

                ////코딩에서 ||오어 연산자는 앞에가 참이면 바로 뒷 스테이트먼트 출ㄹ력함. 
                //내가 짠 if, ifelse 코드보다 훨씬 간략해짐 

08. 모든 아나그ㅐㄹㅁ
    그ㅐㄹ두...잘했는데
    //로직 정답
        //일단 tH 해쉬맵 만들고 
        //
        //lt =0 rt= length of t -1
        //rt 바로 전까지만 만큼 까지만 hashmap sH에 저장
        
        ----루틴
        //이제 rt 해쉬에 추가, 바로 tH와 정확히 일치한지 확인! (따로 function 만들어)
        //lt 빼고 , lt++ 그다음 해쉬맵에 적용 
        // value가 0이 될텐데 그ㅓㄹㅁ key가 ddelete 되어야함 꼭! 0값은 없어
        //그 다음 rt 추가, 하고 바로 비교 
    
    //차이점
    ///tH 만들기, lH 초기화하기 여기까지는 좋은데, 
            //접근 방법이 틀림! while 이 아니라 for 사용해
            //하나 더 추가 해야지 해쉬맵에!
        //compareMaps() 못해쪙


