[1,2차원 배열 탐색]

01 큰 수 출력하기
    try1: 7:59
    //차이점
            //  없다! 똑같음

02 보이는 학생
    try1: 11:38
    //차이점
        // 로직 시행착오 겪음 : 처음에 이거 잘 세우는 게 중요하네
        // 답은: 첫 수가 기준 다음 수가 더 크면 max 재할당. 
        // 1 + max가 몇번 재할당되는지

03 가위 바위 보
    try1: 8:03
    //
        //로직의 시간복잡도가 훨씬 복잡했음

04 점수계산
    try1: 15-18분 정ㅇ도ㅗ
    //차이점
        //  a) total에 plus 더하는거 if 문 내에서 함 난 걍 밖에서 했는데 

05 등수계산
    try1: 27:38 이상. 못품 
    //차이점
        //  a) 야 그래도 배열, 같은 위치에 
        //     나머지 숫자 차례로 iterate 해서 내가 더 작을 때마다 ++하는 거
        //     이 로직은 잘ㄹ해따..
        //  b) Array.from()문법
        //  c) 로직 맞았던 거였어 array.from()안써도 ㅇㅇ
                내가 틀린 건 i=0~4 j=0~4 둘 다 돌아야 전체 비교 가능한데
                j를 i랑 다르게 하려해서

06 격자판 최대합
    try1: 34:21 부터 안 세기 시작했다.....1시간은 족히 걸린 듯
    그치만.....풀었다!!!!!!!!!!!!!!!!
    //차이점
            //  a) 깔끔
            //  b) 내 로직: 행, 열, 대각선의 합을 각각 구해서 마지막에 최댓값 구하자
            //  c) better: 그냥 배열ㄹ의 max 값 구하듯 정말 작은 값이랑
            //              sum1 sum2 를 반복적으로 비교해서
            //              answer에 제일 큰 값이 올 때까지 재할당
            //  d) 내가 틀린 부분: 대각선 합 두번째 구하는 로직. 
            //               for(let i=4; i>=0; i--){ 
            //               해버리면 그냥 대각선 합 1이랑 같아짐

    try2: 12:42
    //놓친점
            //    a) 행&열 합에서 최댓값 재할당 반복할 때 iterate 하면서 합을ㄹ 바꿔주는데 초기화 안해줌
            
            //for(let i=0; i<n; i++){
                sum1=sum2=0;//***놓친부분***초기화 필수!!
                for(let j=0; j<n; j++){
                    sum1 += arr[i][j]; //행 합
                    sum2 += arr[j][i]; //열 합
                }
                //최댓값 재할당 반복(배열에서 찾을 때랑 비슷한 원리)
                answer = Math.max(answer, sum1, sum2);
            }

07 봉우리
    try1: 10:15 못품 --- 가장자리 0으로 초기화되는 거 아리송쓰
        //차이점
            //  a) dx dy nx ny ..봐도 모르겠어
    try2: 10...얼추 갔는데 완성 못함 
        //if(nx>=0 && nx<5 && ny>=0 && ny<5 && arr[i][j]<=arr[nx][ny]){ 
                            flag=0; //봉우리가 아님, 나보다 큰 게 발견
                            break;
                        }