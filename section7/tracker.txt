선택정렬, 그리디 

01 선택정렬
    try1: 
        답: [5, 5, 7, 7, 15, 15] 이렇게 나옴

        //얕은복사
        //나의 문제는 arr[i]랑 arr[idx] swap 하는 코드를ㄹ 잘 못 짰고, 위치도 잘ㄹ모ㅗㅅ돼ㅗㅆ음

        //데이터 swap 해주는 코드 
        //[arr[i], arr[idx]]=[arr[idx], arr[i]];

02 버블정렬
    try1: 성공!
    if(arr[j]>arr[j+1]) 해야 큰수가 뒤로 가징
        //J의 범위 설ㄹ정!!! 
            //n-1 까지 도는 건 불필요함
            //뒤에 숫자가 매 iteration 마다 결정되기 때문에 
            //j가 커질수록 적게 iterate!

03 special sort (버블정렬 응용)
    try1: 성공!!

04 삽입 정렬
    다시 한 번 해보기!

05 Least Recently Used (카카오 캐시 문제 변형)
    로직 배우고 풀었ㅇ므
    답 틀림: [7, 7, 5, 3, 2] 나오ㅘㅆ음;;;ㅓㄹㅈㄹㄷㄹ;;

    틀ㄹ린이유!!!!!!! 
    cache[0]=x;를 for 문 안에서 설정했기 때문에!!! 
    for (let x of arr){
                if(!cache.includes(x)){
                    for(let i=n-1; i>=1; i--){
                        cache[i]=cache[i-1];
                        // cache[0]=x;
                    }
                    cache[0]=x;
                }else{
                    for(let i=cache.indexOf(x); i>=1; i--){
                        cache[i]=cache[i-1];
                        // cache[0]=x;
                    }
                    cache[0]=x;
                }
            } //여기서는 cache[0]=x;라는 statement에 i 값이 전혀 상관 없기 떄문에 
     answer에서는forEach 로도 해보기 

06 장난꾸러기 현수 

    try1: 풀ㄹ었음!
    차이점
        깊은 복사 방법
            난: JSON.parse(JSON.stringify(arr));
            arr.slice() 근데 이건 기본 배열 형태만 가능하고 배열 안 배열이면 안됌
        쓸데없이 two pointers 로 풀었음 

            그냥 for(let i=0; i<arr.lengthh; i++){
                if(arr[i]!==original[i]) answer.push(i+1);하면돼!
            }

07 좌표 정렬

    //좌표 정렬 하는 방법
    //arr.sort((a,b)=>{
                if(a[0]===b[0]) return a[1]-b[1]; //x좌표가 같을 경우 y좌표를 오름차순으로 정렬
                else return a[0]-b[0]; //x좌표 오름차순
            });
    --x값이 같으면 y값 변환

08 회의실 배정 (그리디, 좌표정렬 응용)

    try1: 걍 로직 잘못 이해한거양

    //로직
    //끝나는 시간이 가장 빠른 순서대로 정렬
    //가장 먼저 오는 회의시간을 기준으로 arr[i][0]이 첫 ㅎ회의 끝나는 시간보다 작거나 같은 회의 에서 count
    //여러번 돌지 않고도 바로 최대 회의 시간 찾을 수 있음 

    //그리고 만약 끝나는 시간이 다 같은 회의일 경우 
    //시작시간이 가장 빠른 시간으로 정렬한다음에 끝나는 시간이 다른 회의의 시작 시간과 같은지 확인에서 체크 

    //end time 을 0으로 초기화해놓고 그 값보다 작으면 x[1]으로 초기화해놓기


09 결혼식

    try1: 풀었음 이중 포문, 좌표 정렬 사용 

    //로직

10 이분검색
    //이분검색으로 핳면 O(log(N)) 
            //목적: 검색 범위를 줄이려고 
            //lt를 0, rt를 어레이 끝으로 해놓고
            //mid를 구함 (lt+rt)/2 
            //if (arr[mid]===target) target
            // > 면 rt =mid-1 (미드 기준 앞으로 범위 줄임)
            // < 면 lt =mid+1 (미드 기준 뒤로 범위 줄임)
            
            //똑같이 반복
            //log2의 8 만에 된다 (3번만)
            
11 뮤직비디오(결정알고리즘)
    //기본 베이스가 이분탐색임
    //그냥 solution 말고 결국 답이 몇개가 되는지 되냐 마냐 하는 함수가 제일 중욯함 
    //결정 알고리즘에서! 

    //진짜 자주 나오니까 좀 더 잘 살펴봐라


12 마구간 정하기(결정알고리즘)
    //홓ㄴ자 다시 해보기 