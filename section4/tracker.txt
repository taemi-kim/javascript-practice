완전탐색

01 자릿수의 합
    try1 27:21
        //  1솔! string으로 바꿨다가 숫자로 바꾸는 방법
        // 자릿수 설ㄹ정이 딱 되어있는거몀ㄴ(세자리, 네자리수) 100으로 나누고 10으로 나눌텐데..
        
        //자릿수 합 구하는 로직
        //1) ex. 128
        //2) 128을 10으로 나눔
            //나머지: 8
            //몫: 12
            //나머지를 sum에 더함 
                또 그 몫을 10으로 나눔 
                나머지를 구함. sum에 더함...
                이걸 몫이 0이 될 떄까지. 
        //차이점: 
                    //a) 스트링으로 부수고 합치게 로직이 
                    //  .reduce((a, b)=>a+Number(b), 0); 
                    //  이렇게 활용됐음
                    //b) 나는 sum을 전역, temp을 지역으로 선언해서 비교했는데 
                    //  여기서는 temp없이 sum으로 바로, 왜냐면 max를 MIN_SAFE_INT로 정의해기 땜

02 뒤집은 소수 
    try1 28:31
        //못 품 

        //차이점: 
            //다른 함수 따로 정의해도 되는구나
            //내 로직 맞는데 소수 구하는 시간복잡도 제일 낮고 효율적인 방법은 
            //숫자의 약수들 중 가운데값?을ㄹ 구해서 딱 거기까지만 iterate 하면서 
            혹시나 나머지가 0인 애가 없나 보는 것임 i<parseInt(Math.sqrt(num))

03 멘토링
- 완전탐색을 하는 대표적 문제
        //로직
            //1) (i,j)에서 i를ㄹ 멘토, j를 멘티라고 했을 때 
            //    짝꿍잉 되는 총 경우의 수는 몇 개인지 생각해본다 (4*4=16)
                -> for(for())형식이게지 그럼
                -> 총 경우의 수를 하나하나 다 확인해봐야겠다 <------블루투포스
            //2) 각 배열에서 (i,j)의 인덱스가 i<j인지 확인
                -> 2차원 배열에서 row를 k, col을 s라고 했을ㄹ 때 
                    for문을 한 번더 돌린다
                -> 여기서 test[k][s]가 i값과 같을 때, s값을 pi에 저장한다
                    동일하게 j 값과 같을 때, s값을 pj에 저장
            //3) pi<pj 일 때만 count++

04 졸업선물
    //1)가격 + 배송비 합이 가장 적은 순으로 정렬
            //2)작은 수 부터 다 더하는 게 맞는데, 어디다가 쿠폰 쓰지?
            //<--얠 모르니까 경우의 수 다 해봐야함
            //let min=MAX_SAFE_INTEGER;
    //할인받고 남은 예산
        //예산보다 합이 더 클 경우
        //예산보다 합이 작거나 맞는 경우
        //count랑 answer 중 더 큰 걸로 재 할당

05 K번째 큰 수 
    //차이점    
        //다 못 끝낸 것도 못 끝낸거지만 
        //확장성 없는 코드 만듬   
        for (let i=0; i<m-2; i++){
                for (let j=1; j<m-1; j++){
                    for (let k=2; k<m; k++){
                        sum = arr[i]+arr[j]+arr[j];
                        answer.push(sum);

        얘는 3이라는 값이 fixed 되어 있을 때만 가능  ---> 사실 그게 아니였어 fixed 된 게 맞았어....

        for (let i=0; i<n; i++){ //i<n-2
            for (let j=i+1; j<n; j++){ //j<n-1
                for (let k=j+1; k<n; k++){ //k<n 이렇게가 이론상 맞는데 n으로 한다고 해도 문제 없음 왜냐면 거짓이라 룹 안으로 들어나니까
                    tmp.add(card[i]+card[j]+card[k]);
                }
            }
        }

        temp = Set() //객체
        //Set()이라는 객체 자체는 .sort()함수를 지원하지 않는다
        //.from()을 사용해서 array를 만들고, .sort()도 동시에 할 수 있다 
        //Array.from(tmp).sort((a,b)=>b-a); 